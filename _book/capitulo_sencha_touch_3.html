<!DOCTYPE HTML>
<html lang="en-US" >
    
    <head>
        
        <meta charset="UTF-8">
        <title>Sencha Touch 3. Almacenamiento | Introducción</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 1.0.3">
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    
    <link rel="next" href="./capitulo_phonegap.html" />
    
    
    <link rel="prev" href="./capitulo_sencha_touch_2.html" />
    

        
    </head>
    <body>
        
        
<link rel="stylesheet" href="gitbook/style.css">


        
    <div class="book"  data-level="9" data-basepath="." data-revision="1422271212353">
    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Type to search" class="form-control" />
    </div>
    <ul class="summary">
        
    	
    	
    	

        

        
    
        
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="./index.html">
                        <i class="fa fa-check"></i>
                        
                         Introducción
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1" data-path="capitulo_introduccion_web.html">
            
                
                    <a href="./capitulo_introduccion_web.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                         Introducción al desarrollo Web
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2" data-path="capitulo_introduccion_javascript.html">
            
                
                    <a href="./capitulo_introduccion_javascript.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                         Introducción a JavaScript
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3" data-path="capitulo_diseno_responsive.html">
            
                
                    <a href="./capitulo_diseno_responsive.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                         Diseño Responsive
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="4" data-path="capitulo_diseno_responsive_avanzado.html">
            
                
                    <a href="./capitulo_diseno_responsive_avanzado.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                         Diseño Responsive avanzado
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="5" data-path="capitulo_jquery_mobile.html">
            
                
                    <a href="./capitulo_jquery_mobile.html">
                        <i class="fa fa-check"></i>
                        
                            <b>5.</b>
                        
                         JQuery Mobile
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="6" data-path="capitulo_jquery_mobile_avanzado.html">
            
                
                    <a href="./capitulo_jquery_mobile_avanzado.html">
                        <i class="fa fa-check"></i>
                        
                            <b>6.</b>
                        
                         JQuery Mobile avanzado
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="7" data-path="capitulo_sencha_touch_1.html">
            
                
                    <a href="./capitulo_sencha_touch_1.html">
                        <i class="fa fa-check"></i>
                        
                            <b>7.</b>
                        
                         Sencha Touch 1. Introducción
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="8" data-path="capitulo_sencha_touch_2.html">
            
                
                    <a href="./capitulo_sencha_touch_2.html">
                        <i class="fa fa-check"></i>
                        
                            <b>8.</b>
                        
                         Sencha Touch 2. Componentes
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter active" data-level="9" data-path="capitulo_sencha_touch_3.html">
            
                
                    <a href="./capitulo_sencha_touch_3.html">
                        <i class="fa fa-check"></i>
                        
                            <b>9.</b>
                        
                         Sencha Touch 3. Almacenamiento
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="10" data-path="capitulo_phonegap.html">
            
                
                    <a href="./capitulo_phonegap.html">
                        <i class="fa fa-check"></i>
                        
                            <b>10.</b>
                        
                         PhoneGap 1. Introducción
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="11" data-path="capitulo_phonegap_avanzado.html">
            
                
                    <a href="./capitulo_phonegap_avanzado.html">
                        <i class="fa fa-check"></i>
                        
                            <b>11.</b>
                        
                         PhoneGap 2. Avanzado
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="12" data-path="capitulo_laravel_1.html">
            
                
                    <a href="./capitulo_laravel_1.html">
                        <i class="fa fa-check"></i>
                        
                            <b>12.</b>
                        
                         Laravel 1. Introducción
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="13" data-path="capitulo_laravel_2.html">
            
                
                    <a href="./capitulo_laravel_2.html">
                        <i class="fa fa-check"></i>
                        
                            <b>13.</b>
                        
                         Laravel 2. Controladores, filtros y formularios
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="14" data-path="capitulo_laravel_3.html">
            
                
                    <a href="./capitulo_laravel_3.html">
                        <i class="fa fa-check"></i>
                        
                            <b>14.</b>
                        
                         Laravel 3. Base de datos
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="15" data-path="capitulo_laravel_4.html">
            
                
                    <a href="./capitulo_laravel_4.html">
                        <i class="fa fa-check"></i>
                        
                            <b>15.</b>
                        
                         Laravel 4. Datos de entrada y control de usuarios
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="16" data-path="capitulo_laravel_5.html">
            
                
                    <a href="./capitulo_laravel_5.html">
                        <i class="fa fa-check"></i>
                        
                            <b>16.</b>
                        
                         Laravel 5. Paquetes, Rest y Curl
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="17" data-path="capitulo_rest.html">
            
                
                    <a href="./capitulo_rest.html">
                        <i class="fa fa-check"></i>
                        
                            <b>17.</b>
                        
                         Servicios Rest
                    </a>
                
            
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Published using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    
    <div id="font-settings-wrapper" class="dropdown pull-left">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="buttons">
        <button type="button" id="reduce-font-size" class="button size-2">A</button>
        <button type="button" id="enlarge-font-size" class="button size-2">A</button>
    </div>

    <div class="buttons font-family-list">
        <button type="button" data-font="0" class="button">Serif</button>
        <button type="button" data-font="1" class="button">Sans</button>
    </div>

    <div class="buttons color-theme-list">
        <button type="button" id="color-theme-preview-0" class="button size-3" data-theme="0">White</button>
        <button type="button" id="color-theme-preview-1" class="button size-3" data-theme="1">Sepia</button>
        <button type="button" id="color-theme-preview-2" class="button size-3" data-theme="2">Night</button>
    </div>
</div>

    </div>

    <!-- Actions Right -->
    
    <div class="dropdown pull-right">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle share dropdown"><i class="fa fa-share-alt"></i>
        </a>
        <div class="dropdown-menu font-settings dropdown-left">
            <div class="dropdown-caret">
                <span class="caret-outer"></span>
                <span class="caret-inner"></span>
            </div>
            <div class="buttons">
                <button type="button" data-sharing="twitter" class="button">Twitter</button>
                <button type="button" data-sharing="google-plus" class="button">Google</button>
                <button type="button" data-sharing="facebook" class="button">Facebook</button>
                <button type="button" data-sharing="weibo" class="button">Weibo</button>
                <button type="button" data-sharing="instapaper" class="button">Instapaper</button>
            </div>
        </div>
    </div>
    

    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="./" >Introducción</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-gitbook_19">
                    
                        <h1 id="sencha-touch-3---almacenamiento">Sencha Touch 3 - Almacenamiento</h1>
<p>En esta sección vamos a ver las opciones que tenemos para trabajar con los datos de una aplicación. Para esto Sencha Touch pone a nuestra disposición varias herramientas:</p>
<ul>
<li><em>Data Model</em>: Nos permitirá representar las entidades de datos como colecciones de campos con sus datos asociados.</li>
<li><em>Data Store</em>: Son colecciones de datos de un modelo. Además nos permitirá realizar otro tipo de operaciones más avanzadas como ordenar, filtrar, agrupar o lanzar eventos.</li>
<li><em>Proxy</em>: Permiten cargar y almacenar los datos desde una fuente de datos remota o local en un <em>data model</em> o un <em>data store</em>.</li>
</ul>
<p>Además también se estudiarán varias formas de utilizar estos datos en una aplicación, por ejemplo en listados, <em>data views</em> o en formularios. A continuación veremos en detalle cada uno de estos apartados.</p>
<!-- ********************************************************************* -->
<h2 id="_data-model_"><em>Data Model</em></h2>
<p>Los <em>Data Model</em> nos permiten representar las entidades de datos, junto con sus validaciones de formato y las relaciones con otros modelos, como si estos fuera objetos o clases. Por comparación podríamos pensar que un <em>Data Model</em> es como una clase (en POO) con la definición de los datos que la componen y funciones para poder validar y trabajar con esos datos.</p>
<p>A continuación podemos ver un esquema de todas las opciones que agrupa un <em>Data Model</em>, las cuales iremos viendo se las siguientes secciones:</p>
<p><img src="images/web_sencha/sencha_data_model.png" alt="Data Model" title="Data Model"></p>
<!-- ********************************** -->
<h3 id="definir-un-modelo">Definir un modelo</h3>
<p>Para crear un modelo usamos el constructor <code>Ext.define(&#39;&lt;Model-Name&gt;&#39;, { ... })</code>, en el que como primer parámetro indicamos el nombre del modelo a crear y como segundo parámetro recibe un objeto con la configuración del modelo. En la configuración de modelo tendremos que indicar dos cosas: que hereda de la clase <code>Ext.data.Model</code> y los campos que definen al modelo. Por ejemplo:</p>
<pre><code class="lang-javascript">Ext.define(<span class="hljs-string">'User'</span>, {    <span class="hljs-comment">// Nombre del modelo: User</span>
    extend: <span class="hljs-string">'Ext.data.Model'</span>,
    config: {
        fields: [        <span class="hljs-comment">// Descripción de los campos que lo componen</span>
            { name: <span class="hljs-string">'id'</span>, type: <span class="hljs-string">'int'</span> },
            { name: <span class="hljs-string">'usuario'</span>, type: <span class="hljs-string">'string'</span> },
            { name: <span class="hljs-string">'nombre'</span>,  type: <span class="hljs-string">'string'</span> },
            { name: <span class="hljs-string">'genero'</span>,  type: <span class="hljs-string">'string'</span> },
            { name: <span class="hljs-string">'activo'</span>,  type: <span class="hljs-string">'boolean'</span>, defaultValue: <span class="hljs-literal">true</span>},
            { name: <span class="hljs-string">'fechaRegistro'</span>, type: <span class="hljs-string">'date'</span>, dateFormat: <span class="hljs-string">'c'</span> }
        ]
    }
});
</code></pre>
<p>En este ejemplo hemos creado el modelo <code>User</code> con cinco campos. Por defecto, en todos los modelos se asigna como identificador principal el campo <code>id</code>, el cual se utiliza para varias cosas (como saber si el modelo ha sido guardado). Si queremos variar el campo identificador podemos hacerlo con <code>idProperty: &#39;id&#39;</code>.</p>
<p>Al heredar de la clase <code>Ext.data.Model</code> obtiene una serie de métodos y propiedades que nos van a permitir trabajar con los datos del modelo y almacenarlo de forma permanente.</p>
<p>En la sección <code>fields</code> se definen el resto de campos que componen el modelo. Para cada campo podemos utilizar:</p>
<ul>
<li><em>name</em>: nombre o identificador del campo.</li>
<li><em>type</em>: los campos pueden ser de cinco tipos: <em>string, int, float, boolean, date, auto</em>.</li>
<li><em>defaultValue</em>: atributo opcional que nos permite indicar el valor por defecto de un campo.</li>
<li><em>dateFormat</em>: atributo opcional mediante el cual podemos indicar el formato de la fecha (ver <a href="http://docs.sencha.com/touch/2.4/2.4.1-apidocs/#!/api/Ext.Date" target="_blank">http://docs.sencha.com/touch/2.4/2.4.1-apidocs/#!/api/Ext.Date</a>).</li>
</ul>
<p>Cuando se asigna el tipo <em>auto</em> o no se asigna ningún tipo el campo podrá obtener cualquier tipo de valor y no realizará ninguna validación de formato.</p>
<!-- ********************************** -->
<h3 id="crear-una-instancia-de-un-modelo">Crear una instancia de un modelo</h3>
<p>Para crear una instancia de un modelo utilizamos también el constructor <code>Ext.create(&#39;&lt;Model-Name&gt;&#39;, { ... })</code> especificando el nombre del modelo del cual queremos crear una instancia y un objeto con los valores a asignar a la instancia. Por ejemplo:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> ed = Ext.create(<span class="hljs-string">'User'</span>, {
    usuario: <span class="hljs-string">'ajgallego'</span>,
    nombre: <span class="hljs-string">'Javier Gallego'</span>,
    genero: <span class="hljs-string">'Masculino'</span>,
    activo: <span class="hljs-literal">true</span>
});
</code></pre>
<!-- ********************************** -->
<h3 id="validaciones">Validaciones</h3>
<p>Los modelos de datos incluyen soporte para realizar validaciones, las cuales las deberemos de incluir dentro de la misma clase a continuación del campo <code>fields</code>. Por ejemplo:</p>
<pre><code class="lang-javascript">Ext.define(<span class="hljs-string">'User'</span>, {
    extend: <span class="hljs-string">'Ext.data.Model'</span>,
    config: {
        fields: [
            <span class="hljs-comment">// ...</span>
        ],
        validations: [
            { type: <span class="hljs-string">'presence'</span>,  field: <span class="hljs-string">'nombre'</span> },
            { type: <span class="hljs-string">'length'</span>,    field: <span class="hljs-string">'nombre'</span>, min: <span class="hljs-number">5</span> },
            { type: <span class="hljs-string">'format'</span>,    field: <span class="hljs-string">'usuario'</span>, matcher: <span class="hljs-regexp">/([a-z]+)[0-9]{2,3}/</span>},
            { type: <span class="hljs-string">'inclusion'</span>, field: <span class="hljs-string">'genero'</span>, list: [<span class="hljs-string">'Masculino'</span>, <span class="hljs-string">'Femenino'</span>] },
            { type: <span class="hljs-string">'exclusion'</span>, field: <span class="hljs-string">'usuario'</span>, list: [<span class="hljs-string">'admin'</span>] }
        ]
    }
});
</code></pre>
<p>Los tipos de validaciones que podemos utilizar son los siguientes:</p>
<ul>
<li><em>presence</em>: Indica que el campo es requerido.</li>
<li><em>length</em>: Valida la longitud del campo. Podemos indicar como atributos un mínimo (<em>min</em>) y/o un máximo (<em>max</em>).</li>
<li><em>exclusion</em>: Valida que el valor del campo no se encuentre entre la lista de valores especificados en <em>list</em>.</li>
<li><em>inclusion</em>: Valida que el valor del campo se encuentre entre la lista de valores especificados en <em>list</em>.</li>
<li><em>format</em>: Permite especificar una expresión regular (mediante el atributo <em>matcher</em>) para validar el campo.</li>
</ul>
<p>Además, definiendo el valor de la propiedad <em>message</em>, podemos cambiar el mensaje de error que se produciría si una validación no es correcta:</p>
<pre><code class="lang-javascript">{ field: <span class="hljs-string">'titulo'</span>, type: <span class="hljs-string">'presence'</span>,
  message: <span class="hljs-string">'Por favor, introduzca un título'</span> }
</code></pre>
<p>Cuando trabajemos con un formulario y queramos comprobar estas validaciones lo tendremos que hacer manualmente llamando a la función <code>validate()</code>. A continuación se incluye un ejemplo:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> newUser = Ext.create(<span class="hljs-string">'User'</span>, {
    nombre: <span class="hljs-string">'Javi'</span>,
    usuario: <span class="hljs-string">'admin'</span>,
    genero: <span class="hljs-string">'género no válido'</span>
});

<span class="hljs-keyword">var</span> errors = newUser.validate();

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Válido?'</span>, errors.isValid()); <span class="hljs-comment">// 'false' si hay errores</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Errores:'</span>, errors.items); <span class="hljs-comment">// array con los errores encontrados</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Errores en género:'</span>, errors.getByField(<span class="hljs-string">'genero'</span>));
</code></pre>
<p>Además, como se puede ver en el ejemplo también disponemos de las funciones <code>isValid()</code> para comprobar si han habido errores, <code>.items</code> para obtener el array de errores encontrados y <code>getByField(&#39;&lt;nombre-del-campo&gt;&#39;)</code> para obtener los errores de un campo dado. En la sección de formularios se verá como integrar la validación de un modelo con un formulario.</p>
<!-- ********************************** -->
<h3 id="relaciones-con-otros-modelos">Relaciones con otros modelos</h3>
<p>Los modelos de datos también soportan la creación de relaciones con otros modelos de datos, del tipo &quot;<code>hasMany</code>&quot; y &quot;<code>belongsTo</code>&quot;. Estos contenidos se quedan fuera de este capítulo de introducción por lo que para obtener más información podéis consultar la web:</p>
<p><a href="http://docs.sencha.com/touch/2.4/core_concepts/data/models.html" target="_blank">http://docs.sencha.com/touch/2.4/core_concepts/data/models.html</a></p>
<!-- ********************************** -->
<h3 id="uso-de-modelos-de-datos-en-una-aplicacin">Uso de modelos de datos en una aplicación</h3>
<p>Al crear un modelo lo que estamos haciendo en realidad es crear una nueva definición de una clase (y no una instancia de una clase). Se puede observar la diferencia en el constructor, ya que usamos <code>Ext.define(&#39;&lt;nombre-modelo&gt;&#39;, { ... });</code> en lugar de <code>Ext.create</code>.</p>
<p>En estos casos, en los que creemos nuevas definiciones, estaremos obligados a cargarlos por separado. Para ello Sencha Touch incorpora un potente sistema que nos permite modularizar nuestro código siguiente el patron MVC muy fácilmente. Solamente tendremos que seguir los siguientes pasos:</p>
<ul>
<li><p>Crear una fichero con el mismo nombre que el modelo dentro de la carpeta <code>app/model</code>. Si por ejemplo nuestro modelo se llama <code>User</code> el fichero se tendrá que llamar <code>User.js</code>.</p>
</li>
<li><p>El contenido del fichero del modelo seguirá la sintaxis que hemos visto hasta ahora pero añadiendo el espacio de nombres <code>&lt;nombre-app&gt;.model.&lt;nombre-modelo&gt;</code> al nombre del modelo, por ejemplo si nuestra aplicación se llamase <code>MyApp</code> y el modelo a crear <code>User</code>, el modelo tendría que quedar como el siguiente:</p>
</li>
</ul>
<pre><code class="lang-javascript">Ext.define(<span class="hljs-string">'MyApp.model.User'</span>, {    <span class="hljs-comment">// Nombre del modelo con espacio de nombres</span>
    extend: <span class="hljs-string">'Ext.data.Model'</span>,
    config: {
        fields: [
            { name: <span class="hljs-string">'id'</span>, type: <span class="hljs-string">'int'</span> },
            { name: <span class="hljs-string">'name'</span>, type: <span class="hljs-string">'string'</span> }
        ]
    }
});
</code></pre>
<ul>
<li>Por último tendremos que decirle a nuestra aplicación que cargue la definición del modelo para que podamos utilizarla. Para esto simplemente tenemos que hacer:</li>
</ul>
<pre><code class="lang-javascript">Ext.application({
    name: <span class="hljs-string">'MyApp'</span>,
    models:[<span class="hljs-string">'User'</span>],
    launch: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ ... }
});
</code></pre>
<p>A la hora de <strong>cargar</strong> el modelo podemos indicarlo usando solamente el nombre del modelo o usando el espacio de nombres completo (<code>MyApp.model.User</code>). Pero a la hora de <strong>utilizarlo</strong> (por ejemplo, para crear una instancia del modelo o asociarlo a un <em>store</em>) tendremos que usar la ruta del espacio de nombres completa.</p>
<!-- ********************************************************************* -->
<h2 id="_data-store_"><em>Data Store</em></h2>
<p>Los almacenes de datos (<em>data store</em>) se utilizan para encapsular o almacenar una colección de instancias de un modelo determinado. Además disponen de funciones para ordenar, filtrar y consultar los datos. De forma opcional podemos indicar que utilicen un <em>proxy</em> para sincronizar estos datos con un almacén local o remoto.</p>
<p>En esta sección nos vamos a centrar en las características para gestionar un <em>store</em>: añadir, ordenar, filtrar, buscar y eliminar. En la siguiente sección sobre <em>proxies</em> veremos como hacer persistentes estos datos.</p>
<!-- ********************************** -->
<h3 id="crear-un-_data-store_">Crear un <em>Data Store</em></h3>
<p>Crear un almacén de datos es fácil, utilizaremos el constructor <code>Ext.create(&#39;Ext.data.Store&#39;, {...})</code> y como segundo parámetro le pasaremos las opciones de configuración indicando el nombre del modelo:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myStore = Ext.create(<span class="hljs-string">'Ext.data.Store'</span>, {
    model: <span class="hljs-string">'User'</span>
});
</code></pre>
<!-- ********************************** -->
<h3 id="aadir-datos">Añadir datos</h3>
<p>Podemos añadir datos directamente junto a la definición de un <em>Store</em>, solo tenemos insertarlos como un array a través de su propiedad <em>&quot;data&quot;</em>. Suponiendo que el modelo &quot;User&quot; solo tuviera dos campos (<em>id</em>, <em>name</em>), podríamos añadir datos de la forma:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myStore = Ext.create(<span class="hljs-string">'Ext.data.Store'</span>, {
    model: <span class="hljs-string">'User'</span>,
    data: [
        {id: <span class="hljs-number">1</span>, name: <span class="hljs-string">'Javier Gallego'</span>},
        {id: <span class="hljs-number">2</span>, name: <span class="hljs-string">'Fran García'</span>},
        {id: <span class="hljs-number">3</span>, name: <span class="hljs-string">'Boyan Ivanov'</span>},
        {id: <span class="hljs-number">4</span>, name: <span class="hljs-string">'Miguel Lozano'</span>}
    ]
});
</code></pre>
<p>O también podemos añadir datos posteriormente llamando a la función &quot;<code>add</code>&quot; del objeto:</p>
<pre><code class="lang-javascript">myStore.add({id: <span class="hljs-number">5</span>, name: <span class="hljs-string">'Javier Aznar'</span>},
            {id: <span class="hljs-number">6</span>, name: <span class="hljs-string">'Pablo Suau'</span>});
</code></pre>
<!-- ********************************** -->
<h3 id="ordenar-y-filtrar-elementos">Ordenar y Filtrar elementos</h3>
<p>Para ordenar y filtrar los datos usamos las propiedades &quot;<code>sorters</code>&quot; y &quot;<code>filters</code>&quot;. En el siguiente ejemplo se ordenan los datos de forma descendente por nombre de usuario (también podría ser <code>ASC</code>) y se realiza un filtrado por género (los filtros también admiten expresiones regulares).</p>
<pre><code class="lang-javascript">Ext.create(<span class="hljs-string">'Ext.data.Store'</span>, {
    model: <span class="hljs-string">'User'</span>,
    sorters: [
        { property: <span class="hljs-string">'usuario'</span>, direction: <span class="hljs-string">'DESC'</span> }
    ],
    filters: [
        { property: <span class="hljs-string">'genero'</span>, value: <span class="hljs-string">'Femenino'</span> }
    ]
});
</code></pre>
<!-- ********************************** -->
<h3 id="buscar-registros">Buscar registros</h3>
<p>En algunos casos antes de añadir un registro será necesario comprobar si el registro está repetido. Para esto podemos utilizar el método <code>findRecord(campo, valor)</code> del <em>Store</em>, el cual devuelve el registro encontrado o <em>null</em> en caso de no encontrar ninguna coincidencia. En el siguiente ejemplo se compara el campo <em>id</em> de los datos del <em>Store</em>, con el campo <em>id</em> del registro a añadir:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">if</span> (myStore.findRecord(<span class="hljs-string">'id'</span>, registro.data.id) === <span class="hljs-literal">null</span>)
{
    myStore.add( registro );
}
</code></pre>
<p>Otra opción para buscar registros es la función <code>find(campo, valor)</code> la cual devuelve el índice del registro encontrado (o -1 en caso de no encontrarlo), y posteriormente podríamos llamar a <code>getAt(index)</code> para obtener los datos.</p>
<!-- ********************************** -->
<h3 id="eliminar-registros">Eliminar registros</h3>
<p>Para eliminar un registro de un <em>Store</em> usaremos la función <code>remove(registro)</code>, por ejemplo:</p>
<pre><code class="lang-javascript">myStore.remove( registro );
</code></pre>
<p>Es recomendable comprobar si existe el registro a eliminar, para esto usaremos la función <code>findRecord()</code>. Normalmente el <em>Store</em> estará asignado a algún panel que nos permita ver los datos (como un listado). Si quisiésemos eliminar un registro de este listado, primero tendríamos que obtener el <em>Store</em> usado, a continuación comprobar si existe el registro y si es así eliminarlo. Por último habría que sincronizar los datos para que se visualicen, de la forma:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> store = miListado.getStore();

<span class="hljs-keyword">if</span>( store.findRecord(<span class="hljs-string">'id'</span>, registro.data.id) )
{
    store.remove( registro );
}

store.sync();
miListado.refresh();
</code></pre>
<p>También podemos utilizar la función <code>removeAt(index)</code> para eliminar los registros de un <em>Store</em> a partir de su índice.</p>
<!-- *********************************************************************** -->
<h2 id="_proxy_"><em>Proxy</em></h2>
<p>Los <em>proxies</em> se utilizan para definir la forma de leer y escribir la información. Dependiendo del proxy que utilicemos podremos almacenar los datos de forma local o de forma remota. Además, estos pueden ser definidos tanto en el <em>data store</em> como en el <em>data model</em>.</p>
<p>Los posibles <em>proxies</em> u opciones de almacenamiento que podemos usar son:</p>
<ul>
<li><p>Almacenamiento en local:</p>
<ul>
<li>Memoria (<em>memory</em>): almacenar los datos en memoria.</li>
<li>Local Storage (<em>localstorage</em>): almacenar los datos usando la nueva característica de HTML5 de almacenamiento en local.</li>
<li>Session Storage (<em>sessionstorage</em>): almacenar los datos usando la nueva característica de HTML5 de almacenamiento en local pero por sesión (al cerrar la sesión se borrarán los datos).</li>
<li>SQL (<em>sql</em>): almacenar los datos usando la nueva característica de HTML5 de almacenamiento en una base de datos local de tipo WebSQL.</li>
</ul>
</li>
<li><p>Almacenamiento en remoto:</p>
<ul>
<li>Ajax (<em>ajax</em>): Genera peticiones ajax para cargar o enviar los datos a un servidor.</li>
<li>JsonP (<em>jsonp</em>): JSONP o JSON con padding es una técnica de comunicación utilizada para realizar llamadas asíncronas a dominios diferentes y de esta forma evitar los errores por peticiones <em>cross-domain</em>.</li>
<li>Rest (<em>rest</em>): Especialización del <em>proxy</em> ajax para realizar peticiones a un servidor RESTful.</li>
</ul>
</li>
</ul>
<p>A continuación se tratarán las posibles formas de definición de un <em>proxy</em> y algunos ejemplos de uso usando los tipos <em>ajax</em>, <em>localstorage</em> y <em>rest</em>.</p>
<!-- ********************************** -->
<h3 id="definir-el-_proxy_-en-el-_data-store_">Definir el <em>proxy</em> en el <em>Data Store</em></h3>
<p>En un <em>Data Store</em>, además de definir el modelo asociado, podemos definir el <em>proxy</em> a utilizar. En el siguiente ejemplo se configura un <em>proxy</em> de tipo <em>ajax</em>, además se le proporciona la <code>url</code> con la dirección para acceder a los datos y la propiedad <code>reader</code> para especificar el tipo de datos con los que tiene que trabajar.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myStore = Ext.create(<span class="hljs-string">'Ext.data.Store'</span>, {
    model: <span class="hljs-string">'User'</span>,
    proxy: {
        type: <span class="hljs-string">'ajax'</span>,
        url : <span class="hljs-string">'users.json'</span>,
        reader: <span class="hljs-string">'json'</span>
    },
    autoLoad: <span class="hljs-literal">true</span>
});
</code></pre>
<p>Además hemos añadido la propiedad <code>autoLoad: true</code> para que se carguen los datos al inicio desde el proxy indicado. Si no lo hiciéramos así el <em>store</em> inicialmente estaría vacío, aunque también podríamos cargarlos utilizando el método <code>myStore.load()</code>.</p>
<p>La propiedad <code>reader</code> especifica la forma de codificar / decodificar los datos. En este caso se ha especificado el tipo <em>json</em>, pero Sencha Touch admite también el tipo <em>xml</em>.</p>
<p>Al cargar la aplicación con el <em>store</em> del ejemplo se auto-descargarían los datos desde la URL indicada. A continuación, y según tiene definido el <em>store</em>, espera recibir un objeto JSON con un array de datos con los mismos campos que el modelo <em>User</em> asociado. El formato de los datos en JSON debería ser similar al siguiente:</p>
<pre><code class="lang-javascript">{
    success: <span class="hljs-literal">true</span>,
    users: [
        { id: <span class="hljs-number">1</span>, name: <span class="hljs-string">'Greg'</span> },
        { id: <span class="hljs-number">2</span>, name: <span class="hljs-string">'Seth'</span> }
    ]
}
</code></pre>
<p>En caso de que la raíz de los datos del array fuese distinta podríamos indicarlo configurando el <code>reader</code> de la forma:</p>
<pre><code class="lang-javascript">    ...
    proxy: {
        type: <span class="hljs-string">'ajax'</span>,
        url : <span class="hljs-string">'users.json'</span>,
        reader: {
            type: <span class="hljs-string">'json'</span>,
            root: <span class="hljs-string">'usersList'</span>
        }
    }
</code></pre>
<!-- ********************************** -->
<h3 id="definir-el-_proxy_-en-el-_data-model_">Definir el <em>proxy</em> en el <em>Data Model</em></h3>
<p>El <em>proxy</em> también se puede definir directamente en el modelo de datos, lo cual tiene dos beneficios. Primero, si el modelo se utiliza en varios <em>stores</em> solo se tendrá que especificar una vez la configuración del <em>proxy</em>. Y segundo, podremos cargar datos y guardarlos sin necesidad de referenciar el <em>store</em>.</p>
<p>En el siguiente ejemplo se puede ver como definir un <em>proxy</em> directamente en el modelo (las opciones de configuración son exactamente las mismas que si lo hiciéramos en el <em>store</em>):</p>
<pre><code class="lang-javascript">Ext.define(<span class="hljs-string">'User'</span>, {
    extend: <span class="hljs-string">'Ext.data.Model'</span>,
    config: {
        fields: [<span class="hljs-string">'id'</span>, <span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>, <span class="hljs-string">'gender'</span>],
        proxy: {
            type: <span class="hljs-string">'rest'</span>,
            url : <span class="hljs-string">'data/users'</span>,
            reader: {
                type: <span class="hljs-string">'json'</span>,
                root: <span class="hljs-string">'users'</span>
            }
        }
    }
});

<span class="hljs-comment">// Definimos el store y lo asociamos, el cual ya tendrá configurado el proxy</span>
<span class="hljs-keyword">var</span> myStore = Ext.create(<span class="hljs-string">'Ext.data.Store'</span>, {
    model: <span class="hljs-string">'User'</span>
});
</code></pre>
<p>En este otro ejemplo se muestra como guardar y cargar datos directamente desde el modelo que hemos creado en el ejemplo anterior:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Crear un usuario</span>
<span class="hljs-keyword">var</span> item = Ext.create(<span class="hljs-string">'User'</span>, {
    name: <span class="hljs-string">'Bilbo Bolsón'</span>,
    age : <span class="hljs-number">25</span>
});

<span class="hljs-comment">// Almacenar el usuario creado. Esto enviará una petición tipo POST</span>
<span class="hljs-comment">// a la ruta "/users", ya que tiene definido un proxy tipo rest.</span>
item.save({
    success: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"El usuario se ha guardado con ID: "</span>+ item.getId());
    }
});

<span class="hljs-comment">// Obtener una referencia al modelo User</span>
<span class="hljs-keyword">var</span> User = Ext.ModelMgr.getModel(<span class="hljs-string">'User'</span>);

<span class="hljs-comment">// Cargar el usuario con id = 1</span>
User.load(<span class="hljs-number">1</span>, {
    success: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(user)</span> </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Usuario 1 con nombre: "</span> + user.get(<span class="hljs-string">'name'</span>));
    }
});
</code></pre>
<!-- ********************************** -->
<h3 id="almacenamiento-en-local-con-_localstorage_">Almacenamiento en local con <em>localstorage</em></h3>
<p>Para este tipo de almacenamiento, el proxy utiliza la nueva funcionalidad de HTML5 de almacenamiento en local. Esta opción es muy útil para almacenar información sin la necesidad de utilizar un servidor. Sin embargo solo podremos guardar pares clave-valor, no soporta objetos complejos como JSON (<em>JavaScript Object Notation</em>).</p>
<p>Al usar almacenamiento en local es muy importante que el modelo de datos tenga un &quot;id&quot; único, que por defecto tendrá ese nombre de campo (<em>id</em>); en caso de utilizar otro lo podríamos indicar mediante la propiedad &quot;<code>idProperty: &#39;myID&#39;</code>&quot; del modelo.</p>
<p>Para que el proxy utilice el almacenamiento en local simplemente tendremos que indicar el tipo (<code>type: &#39;localstorage&#39;</code>) y un identificador (<code>id</code>, usado como clave para guardar los datos). En el siguiente ejemplo se crea un almacén de datos para el modelo &quot;User&quot; que hemos definido en las secciones anteriores.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myStore = Ext.create(<span class="hljs-string">'Ext.data.Store'</span>, {
    model: <span class="hljs-string">'User'</span>,
    proxy: {
        type: <span class="hljs-string">'localstorage'</span>,
        id: <span class="hljs-string">'my-store-id'</span>
    },
    autoLoad: <span class="hljs-literal">true</span>
});
</code></pre>
<!-- ********************************************************************* -->
<h2 id="plantillas">Plantillas</h2>
<p>Las plantillas se utilizan para describir la disposición y la apariencia visual de los datos de nuestra aplicación. Nos proporcionan funcionalidad avanzada para poder procesarlos y darles formato, como: auto-procesado de arrays, condiciones, operaciones matemáticas, ejecución de código en línea, variables especiales, funciones, etc.</p>
<p>Para instanciar un template utilizamos el constructor &quot;<code>Ext.XTemplate( template )</code>&quot;, donde <em>template</em> será una cadena con la definición del template a utilizar. Posteriormente podemos utilizar la función &quot;`overwrite(elemento, datos)´&quot; del <em>template</em> para aplicar un template con unos datos sobre un elemento dado. En la sección de &quot;Visualización de datos&quot; se detalla otra forma de aplicar un template en un panel.</p>
<!-- ********************************************************************* -->
<h3 id="auto-procesado-de-arrays">Auto-procesado de arrays</h3>
<p>Para crear un template que procese automáticamente un array se utiliza la etiqueta <code>&lt;tpl for=&quot;variable&quot;&gt;plantilla&lt;/tpl&gt;</code>, teniendo en cuenta que:</p>
<ul>
<li>Si el valor especificado es un array se realizará un bucle por cada uno de sus elementos, repitiendo el código de la &quot;plantilla&quot; para cada elemento.</li>
<li>La &quot;plantilla&quot; puede contener texto, etiquetas HTML y variables o elementos del array a sustituir.</li>
<li>Las variables a sustituir se indican de la forma &quot;<code>{nombre_variable}</code>&quot;, donde &quot;<code>nombre_variable</code>&quot; debe de corresponder con el nombre de una de los elementos del array iterado.</li>
<li>Mediante la variable especial <code>{#}</code> podemos obtener el índice actual del array.</li>
<li>En la sección <code>for=&quot;variable&quot;</code> de la plantilla se debe de indicar el nombre de la variable que contiene el array a procesar, de la forma:<ul>
<li>Con <code>&lt;tpl for=&quot;.&quot;&gt;...&lt;/tpl&gt;</code> se ejecuta un bucle a partir del nodo raíz.</li>
<li>Con <code>&lt;tpl for=&quot;foo&quot;&gt;...&lt;/tpl&gt;</code> se ejecuta el bucle a partir del nodo &quot;foo&quot;.</li>
<li>Con<code>&lt;tpl for=&quot;foo.bar&quot;&gt;...&lt;/tpl&gt;</code> se ejecuta el bucle a partir del nodo &quot;foo.bar&quot;</li>
</ul>
</li>
</ul>
<p>Si por ejemplo tenemos el siguiente objeto de datos:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myData = {
  name: <span class="hljs-string">'Tommy Maintz'</span>,
  drinks: [<span class="hljs-string">'Agua'</span>, <span class="hljs-string">'Café'</span>, <span class="hljs-string">'Leche'</span>],
  kids: [
    { name: <span class="hljs-string">'Tomás'</span>, age:<span class="hljs-number">3</span> },
    { name: <span class="hljs-string">'Mateo'</span>, age:<span class="hljs-number">2</span> },
    { name: <span class="hljs-string">'Salomón'</span>, age:<span class="hljs-number">0</span> }
  ]
};
</code></pre>
<p>Podríamos mostrar un listado con el contenido de <code>myData.kids</code> indicando en la sección <code>for=&quot;variable&quot;</code> que procese a partir de la raíz del array a procesar (<code>myData.kids</code>):</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myTpl = <span class="hljs-keyword">new</span> Ext.XTemplate(
  <span class="hljs-string">'&lt;tpl for="."&gt;'</span>,
    <span class="hljs-string">'&lt;p&gt;{#}. {name}&lt;/p&gt;'</span>,
  <span class="hljs-string">'&lt;/tpl&gt;'</span> );

myTpl.overwrite(myPanel.element, myData.kids);
</code></pre>
<p>Si por ejemplo indicamos que se procese la variable &quot;<em>myData</em>&quot; y queremos obtener el mismo resultado, tendríamos que modificar el <em>template</em> para que se procese a partir del nodo &quot;<em>kids</em>&quot;, de la forma <code>&lt;tpl for=&quot;kids&quot;&gt;...&lt;/tpl&gt;</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myTpl = <span class="hljs-keyword">new</span> Ext.XTemplate(
  <span class="hljs-string">'&lt;tpl for="kids"&gt;'</span>,
    <span class="hljs-string">'&lt;p&gt;{#}. {name}&lt;/p&gt;'</span>,
  <span class="hljs-string">'&lt;/tpl&gt;'</span> );

myTpl.overwrite(myPanel.element, myData);
</code></pre>
<p>Si el array solo contiene valores (en el objeto de datos de ejemplo, sería el array &quot;<em>drinks</em>&quot;), podemos usar la variable especial <code>{.}</code> dentro del bucle para obtener el valor actual:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myTpl = <span class="hljs-keyword">new</span> Ext.XTemplate(
  <span class="hljs-string">'&lt;tpl for="drinks"&gt;'</span>,
    <span class="hljs-string">'&lt;p&gt;{#}. {.}&lt;/p&gt;'</span>,
  <span class="hljs-string">'&lt;/tpl&gt;'</span> );

myTpl.overwrite(myPanel.element, myData);
</code></pre>
<!-- ********************************************************************* -->
<h3 id="condiciones">Condiciones</h3>
<p>Para introducir condiciones en las plantillas se utiliza la etiqueta <code>&lt;tpl if=&quot;condicion&quot;&gt; plantilla &lt;/tpl&gt;</code>. Hemos de tener en cuenta que: si utilizamos símbolos como las &quot;<code>&lt;</code>&quot;, &quot;<code>&gt;</code>&quot; o las &quot;comillas&quot; deberemos escribirlos codificados: <code>&amp;lt;</code>, <code>&amp;gt;</code> o <code>&amp;quot;</code>; y que si usamos los operadores &quot;<code>elseif</code>&quot; o &quot;<code>else</code>&quot; tendremos que cerrar la plantilla al final.</p>
<p>Ejemplos:</p>
<pre><code class="lang-javascript">&lt;tpl if="age &amp;lt; 10"&gt;
    Niño
&lt;tpl elseif="age &amp;gt= 10 &amp;&amp; age &amp;lt; 18"&gt;
    Adolescente
&lt;tpl else&gt;
    Adulto
&lt;/tpl&gt;
&lt;tpl if="name == &amp;quot;Javi&amp;quot;"&gt;¡Hola Javi!&lt;/tpl&gt;
</code></pre>
<!-- ********************************************************************* -->
<h3 id="visualizacin">Visualización</h3>
<p>Para renderizar el contenido de una plantilla sobre un panel (u otro elemento que lo soporte, como veremos más adelante), podemos usar la función &quot;<code>tpl.overwrite(elemento, datos)</code>&quot; que ya hemos usado en los ejemplos anteriores. O usar la propiedades &quot;<code>tpl</code>&quot; junto con &quot;<code>data</code>&quot;, de la forma:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myPanel = Ext.create(<span class="hljs-string">'Ext.Panel'</span>, {
    data: myData,
    tpl: myTpl
});

<span class="hljs-comment">// O también:</span>
<span class="hljs-comment">// myTpl.overwrite(myPanel.element, myData);</span>
</code></pre>
<!-- ********************************************************************* -->
<h2 id="_data-views_"><em>Data Views</em></h2>
<p>Los <em>Data Views</em> nos permiten mostrar datos de forma personalizada mediante el uso de plantillas y opciones de formato. Principalmente se utilizan para mostrar datos provenientes de un <em>store</em> y aplicarles formato utilizando las plantillas &quot;<code>Ext.XTemplate</code>&quot;, como hemos visto en la sección anterior. Además también proporcionan mecanismos para gestionar eventos como: <em>click, doubleclick, mouseover, mouseout</em>, etc., así como para permitir seleccionar los elementos mostrados (por medio de un &quot;<em>itemSelector</em>&quot;).</p>
<p>En el siguiente ejemplo vamos a crear un <em>DataView</em> para mostrar el contenido de un <em>store</em> definido por separado y mediante la utilización de una plantilla también previamente definida usando <code>Ext.XTemplate</code>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myDataView = Ext.create(<span class="hljs-string">'Ext.DataView'</span>, {
    fullscreen: <span class="hljs-literal">true</span>,
    store: myStore,
    tpl: myTpl
});
</code></pre>
<p>En este otro ejemplo creamos un <em>DataView</em> para mostrar el contenido de un <em>store</em> que incluimos dentro de la propia clase con un array de datos interno. Además utilizamos la propiedad <code>itemTpl</code> el lugar de <code>tpl</code>, lo que nos permite indicar el <em>template</em> de cada elemento o <em>item</em> del array directamente.</p>
<pre><code class="lang-javascript">Ext.create(<span class="hljs-string">'Ext.DataView'</span>, {
    fullscreen: <span class="hljs-literal">true</span>,
    store: {
        fields: [<span class="hljs-string">'name'</span>,<span class="hljs-string">'age'</span>],
        data: [
            {name:<span class="hljs-string">'Manuel'</span>, age:<span class="hljs-number">21</span>},
            {name:<span class="hljs-string">'Pedro'</span>, age:<span class="hljs-number">56</span>},
            {name:<span class="hljs-string">'Javi'</span>, age:<span class="hljs-number">36</span>},
            {name:<span class="hljs-string">'Laura'</span>, age:<span class="hljs-number">57</span>},
            {name:<span class="hljs-string">'Alfredo'</span>, age:<span class="hljs-number">11</span>},
            {name:<span class="hljs-string">'María'</span>, age:<span class="hljs-number">12</span>}
        ]
    },
    itemTpl: <span class="hljs-string">'{name} tiene {age} años'</span>
});
</code></pre>
<p>Esta &quot;vista de datos&quot; podemos mostrarla en nuestra aplicación tal cual la hemos creado o también podemos añadirla a la sección <code>items</code> de un panel:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myPanel = Ext.create(<span class="hljs-string">'Ext.Panel'</span>, {
    fullscreen: <span class="hljs-literal">true</span>,
    items: [ myDataView ]
});
</code></pre>
<!-- ********************************************************************* -->
<h3 id="listados">Listados</h3>
<p>Permiten mostrar datos en forma de listado a partir de una plantilla por defecto de tipo lista. Estos datos se obtienen directamente de un &quot;<em>store</em>&quot; y se mostrarán uno a uno en forma de listado según la plantilla definida en &quot;<code>itemTpl</code>&quot;. Además incorpora funcionalidades para gestionar eventos como: <em>itemtap</em>, <em>itemdoubletap</em>, <em>containertap</em>, etc.</p>
<p>Utilizarlo es muy simple, solo tenemos que definir el &quot;<em>store</em>&quot; que queremos utilizar y la plantilla para cada uno de los elementos con &quot;<code>itemTpl</code>&quot;, por ejemplo:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myList = Ext.create(<span class="hljs-string">'Ext.List'</span>, {
    fullscreen: <span class="hljs-literal">true</span>,
    store: {
        fields: [<span class="hljs-string">'firstName'</span>, <span class="hljs-string">'lastName'</span>],
        data: [
            {firstName: <span class="hljs-string">'Pedro'</span>, lastName: <span class="hljs-string">'García'</span>},
            {firstName: <span class="hljs-string">'Jorge'</span>, lastName: <span class="hljs-string">'Sánchez'</span>},
            {firstName: <span class="hljs-string">'Sandra'</span>, lastName: <span class="hljs-string">'Gallego'</span>},
            {firstName: <span class="hljs-string">'María'</span>, lastName: <span class="hljs-string">'Pérez'</span>}
        ]
    },
    itemTpl: <span class="hljs-string">'{firstName} {lastName}'</span>
});
</code></pre>
<p>En el ejemplo anterior hemos creado el <em>store</em> a utilizar directamente dentro de la lista con un array de datos interno, pero también podríamos crear el <em>store</em> de datos por separado y conectarlo alguna fuente de datos local o remota (como se vio en la sección correspondiente):</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myList = Ext.create(<span class="hljs-string">'Ext.List'</span>, {
    fullscreen: <span class="hljs-literal">true</span>,
    store: myStore,
    itemTpl: <span class="hljs-string">'{firstName} {lastName}'</span>
});
</code></pre>
<p>El código del ejemplo generaría una aplicación como la siguiente:</p>
<p><img src="images/web_sencha/sencha_list_1.png" alt=""></p>
<p>Es muy importante diferenciar &quot;<code>itemTpl</code>&quot; de la propiedad &quot;<code>tpl</code>&quot; que ya habíamos visto (en las que usábamos los <code>XTemplate</code>). En &quot;<code>itemTpl</code>&quot; se procesa cada elemento del listado individualmente. Otra diferencia es que tenemos que utilizar como separador para la concatenación el símbolo de unión &quot;+&quot; y no la coma &quot;,&quot;.</p>
<p>Esta lista ya la podemos mostrar directamente, sin la necesidad de incluirla en un contenedor, sin embargo, también podemos añadirla dentro de un panel en su sección <code>items</code> de la forma:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myPanel = Ext.create(<span class="hljs-string">'Ext.Panel'</span>, {
    layout: <span class="hljs-string">'fit'</span>,
    items: [ myList ]
});
</code></pre>
<blockquote>
<p>Nota: es posible que al asignar un listado a un panel no se visualice correctamente. En este caso tenemos que asegurarnos de eliminar la propiedad <code>fullscreen</code> tanto del listado como del panel y de asignar el <code>layout: &#39;fit&#39;</code> al panel (y ningún layout al listado).</p>
</blockquote>
<p>En el &quot;<em>store</em>&quot; debemos de utilizar la propiedad &quot;<code>sorters</code>&quot; para ordenar el listado, pues sino nos aparecerá desordenado. Por ejemplo, podríamos indicar (en el &quot;<em>store</em>&quot;) que se ordene por el apellido &quot;<code>sorters: &#39;lastName&#39;</code>&quot;.</p>
<!-- ********************************************************************* -->
<h3 id="obtener-datos-de-la-lista">Obtener datos de la lista</h3>
<p>Para obtener el almacén de datos asociado a un listado utilizamos su método <code>getStore()</code>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> notesStore = myList.getStore();
</code></pre>
<p>Una vez obtenido ya podemos realizar operaciones sobre él como añadir, modificar o eliminar algún registro (consultar sección correspondiente).</p>
<!-- ********************************************************************* -->
<h3 id="actualizar-datos">Actualizar datos</h3>
<p>Si modificamos el almacén de datos asociado con el listado tendremos que actualizarlo para que se visualicen correctamente los nuevos datos en el listado. En primer lugar llamaremos al método <code>sync()</code> del <em>store</em> para sincronizar los cambios. A continuación, si es necesario, ordenamos los datos (pues el registro se habrá añadido al final). En el ejemplo se ordenan de forma descendente por fecha. Por último llamamos al método <code>refresh()</code> del listado para actualizar la vista.</p>
<pre><code class="lang-javascript">notesStore.add( registro );

notesStore.sync();
notesStore.sort([{ property: <span class="hljs-string">'date'</span>, direction: <span class="hljs-string">'DESC'</span>}]);
myList.refresh();
</code></pre>
<!-- ********************************************************************* -->
<h3 id="agrupar-elementos">Agrupar elementos</h3>
<p>Una propiedad muy útil que nos ofrecen los listados es la posibilidad de agrupar los elementos (como podemos ver en la imagen inferior). Para esto activaremos la propiedad &quot;<code>grouped: true</code>&quot; del listado y opcionalmente podremos indicar que se muestre una barra lateral de navegación &quot;<code>indexBar: true</code>&quot;.</p>
<p><img src="images/web_sencha/sencha_listado.jpg" alt=""></p>
<p>Pero para que esta propiedad funcione correctamente tendremos que indicar dentro del <em>store</em> la forma de agrupar los elementos. Tenemos dos opciones:</p>
<ul>
<li><p><code>groupField: &#39;campo&#39;</code> - para agrupar por un campo (por ejemplo: elementos de género masculino y femenino).</p>
</li>
<li><p><code>getGroupString: function(instance) {...}</code> - para agrupar usando una función. Esta opción es mucho más avanzada y nos permitirá agrupar, por ejemplo, usando la primera letra del apellido (como se muestra en la imagen de ejemplo).</p>
</li>
</ul>
<p>Para obtener el resultado de la imagen de ejemplo anterior, el código quedaría como el siguiente:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myStore = Ext.create(<span class="hljs-string">'Ext.data.Store'</span>, {
    model: <span class="hljs-string">'User'</span>,
    proxy: {
        type: <span class="hljs-string">'localstorage'</span>,
        id: <span class="hljs-string">'my-store-id'</span>
    },
    autoLoad: <span class="hljs-literal">true</span>,
    sorters: <span class="hljs-string">'apellido'</span>,
    getGroupString: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(instance)</span> </span>{
        <span class="hljs-keyword">return</span> instance.get(<span class="hljs-string">'apellido'</span>)[<span class="hljs-number">0</span>];
    }
});

<span class="hljs-keyword">var</span> myList = Ext.create(<span class="hljs-string">'Ext.List'</span>, {
    fullscreen: <span class="hljs-literal">true</span>,
    store: myStore,
    grouped : <span class="hljs-literal">true</span>,
    indexBar: <span class="hljs-literal">true</span>,
    itemTpl: <span class="hljs-string">'{nombre} {apellido}'</span>
});
</code></pre>
<!-- ********************************************************************* -->
<h3 id="acciones">Acciones</h3>
<p>Para añadir acciones al presionar sobre un elemento del listado tenemos varias opciones:</p>
<ul>
<li><p><code>itemtap</code>: permite realizar una acción al presionar sobre un elemento de la barra. Este evento lo debemos definir dentro de la sección &quot;<code>listeners</code>&quot; de nuestro <code>Ext.List</code>, de la forma:
<br/></p>
<pre><code class="lang-javascript">listeners: {
  itemtap: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view, index, target, record)</span> </span>{
      alert( <span class="hljs-string">"tap on"</span> + index );
  }
}
</code></pre>
<p><br/>
Donde el parámetro <em>record</em> representa el objeto sobre el que se ha pulsado. Este valor lo podríamos aprovechar para cargarlo directamente en un formulario o realizar alguna operación con él.</p>
</li>
<li><p><code>itemdoubletap</code>: permite realizar una acción al presionar dos veces consecutivas sobre un elemento. Este evento lo debemos definir dentro de la sección &quot;<code>listeners</code>&quot; de nuestro <code>Ext.List</code>, de la forma:
<br/></p>
<pre><code class="lang-javascript">listeners: {
  itemdoubletap: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view, index, target, record)</span></span>{
      alert(<span class="hljs-string">"doubletap on "</span>+index);
  }
}
</code></pre>
<p><br/>
Donde el parámetro <em>record</em> representa el objeto sobre el que se ha pulsado.</p>
</li>
<li><p><code>onItemDisclosure: Boolean / Función</code> - esta propiedad admite diferentes valores. Si le indicamos el valor booleano &quot;true&quot; simplemente añadirá un icono con una flecha a la derecha de cada elemento (como podemos ver en la imagen inferior).
<br/>
<br/>
<img src="images/web_sencha/sencha_listado_botones.jpg" alt="">
<br/>
<br/>
En lugar de un valor booleano, podemos indicarle una función. En este caso, además de añadirse el icono en cada elemento, también se ejecutará la función cada vez que se presiones sobre dicho icono. Solo se capturará cuando se presione sobre el icono, no sobre toda la barra (como en el caso de <em>itemtap</em>). A continuación se incluye un ejemplo de uso:
<br/></p>
<pre><code class="lang-javascript">onItemDisclosure: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(record)</span> </span>{ alert( <span class="hljs-string">"item disclosure"</span> ); }
</code></pre>
<p><br/>
Donde el parámetro <em>record</em> representa el objeto sobre el que se ha pulsado. En el siguiente código, al pulsar sobre un elemento de la lista se cargan los datos del elemento pulsado en un formulario (como veremos más adelante), y se cambia la vista para visualizar ese panel.
<br/></p>
<pre><code class="lang-javascript">onItemDisclosure: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( record )</span>
</span>{
  myFormPanel.setRecord( record );
  panelPrincipal.animateActiveItem(
          myFormPanel,
          { type: <span class="hljs-string">'slide'</span>, direction: <span class="hljs-string">'left'</span> });
}
</code></pre>
</li>
</ul>
<!-- ********************************************************************* -->
<h2 id="formularios">Formularios</h2>
<p>En esta sección vamos a ver como podemos cargar, guardar y validar los datos de un formulario.</p>
<!-- ********************************************************************* -->
<h3 id="cargar-datos-en-un-formulario">Cargar datos en un formulario</h3>
<p>Para insertar datos de un modelo en un formulario utilizamos el método &quot;<code>setRecord( data )</code>&quot; de la clase &quot;<code>Ext.form.Panel</code>&quot;. En el siguiente ejemplo se crea un formulario con dos campos llamados &quot;<em>title</em>&quot; y &quot;<em>text</em>&quot; y a continuación se cargan los datos del registro &quot;<em>note</em>&quot;.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> noteEditor = Ext.create(<span class="hljs-string">'Ext.form.Panel'</span>, {
  id: <span class="hljs-string">'noteEditor'</span>,
  fullscreen: <span class="hljs-literal">true</span>,
  items: [ {
      xtype: <span class="hljs-string">'textfield'</span>,
      name: <span class="hljs-string">'title'</span>,
      label: <span class="hljs-string">'Title'</span>,
      required: <span class="hljs-literal">true</span>
    }, {
      xtype: <span class="hljs-string">'textareafield'</span>,
      name: <span class="hljs-string">'narrative'</span>,
      label: <span class="hljs-string">'Narrative'</span>
    } ]
});

noteEditor.setRecord( note );
</code></pre>
<p>El método &quot;<code>setRecord( data )</code>&quot; recibe como parámetro una instancia de un modelo de datos (ver sección <em>Data Model</em>), del cual cargará solamente los campos cuyos nombre coincidan con los establecidos en el formulario. En este formulario tenemos dos campos: &quot;<code>name: &#39;title&#39;</code>&quot; y &quot;<code>name: &#39;text&#39;</code>&quot;, si cargamos una instancia de un modelo de datos como el descrito a continuación, solamente se cargarían los dos campos que coinciden.</p>
<pre><code class="lang-javascript">Ext.define(<span class="hljs-string">'Note'</span>, {
    extend: <span class="hljs-string">'Ext.data.Model'</span>,
    config: {
        fields: [
            { name: <span class="hljs-string">'id'</span>, type: <span class="hljs-string">'int'</span> },
            { name: <span class="hljs-string">'date'</span>, type: <span class="hljs-string">'date'</span>, dateFormat: <span class="hljs-string">'c'</span> },
            { name: <span class="hljs-string">'title'</span>, type: <span class="hljs-string">'string'</span> },
            { name: <span class="hljs-string">'text'</span>, type: <span class="hljs-string">'string'</span> }
        ]
    }
});
</code></pre>
<p>En la sección de &quot;<em>Data Model</em>&quot; ya hemos visto que podemos usar la función &quot;<code>Ext.create(&#39;&lt;nombre-modelo&gt;&#39;, {lista-valores})</code>&quot; para crear instancias de un modelo de datos. En el siguiente ejemplo se crea una instancia del modelo anterior y se añade al formulario &quot;noteEditor&quot; que habíamos definido anteriormente. En este caso, al asignar los datos al formulario, solo se cargarían los campos &quot;<em>title</em>&quot; y &quot;<em>text</em>&quot;.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> note = Ext.create(<span class="hljs-string">'Note'</span>, {
    id: <span class="hljs-number">1</span>,
    date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
    title: <span class="hljs-string">'titulo'</span>,
    text: <span class="hljs-string">'texto'</span>
});

noteEditor.setRecord( note );
</code></pre>
<p>A continuación se incluye un ejemplo un poco más avanzado: Creamos una barra de herramientas a la que añadimos un botón con el texto &quot;Cargar datos&quot;. Para este botón definimos su función &quot;<code>handler</code>&quot;, de forma que al pulsar el botón se crea una instancia del modelo &#39;Note&#39; y posteriormente se carga en el formulario &#39;noteEditor&#39;.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myToolbar = Ext.create(<span class="hljs-string">'Ext.Toolbar'</span>, {
    docked: <span class="hljs-string">'top'</span>,
    title: <span class="hljs-string">'Mi barra'</span>,
    items: [
        {
            xtype: <span class="hljs-string">'button'</span>,
            ui: <span class="hljs-string">'action'</span>,
            text: <span class="hljs-string">'Cargar datos'</span>,
            handler: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
                <span class="hljs-keyword">var</span> noteId = now.getTime();
                <span class="hljs-keyword">var</span> note = Ext.create(<span class="hljs-string">'Note'</span>, {
                    id: noteId,
                    date: now,
                    title: <span class="hljs-string">'titulo'</span>,
                    text: <span class="hljs-string">'texto'</span>
                });
                noteEditor.setRecord( note );
            }
        }
    ]
});
</code></pre>
<!-- ********************************************************************* -->
<h3 id="guardar-los-datos-de-un-formulario">Guardar los datos de un formulario</h3>
<p>Para guardar los datos de un formulario en general tendremos que seguir cuatro pasos:</p>
<ul>
<li><p>En primer lugar llamamos al método <code>getRecord()</code> del formulario para obtener su modelo de datos asociado, el cual devolverá un objeto del tipo <code>Ext.data.Model</code> con la definición de los campos utilizados en el formulario, pero no sus valores.</p>
</li>
<li><p>A continuación llamamos a la función <code>updateRecord(objeto)</code> del mismo formulario para transferir los valores introducidos a la instancia del modelo que hemos obtenido antes.</p>
</li>
<li><p>En tercer lugar tenemos que realizar el proceso de validación de los datos (explicado en el siguiente apartado).</p>
</li>
<li><p>Y por último guardar los datos en el <em>store</em> correspondiente. Si tenemos una instancia del almacén de datos creada (ver sección <em>Data Store</em>) podemos añadir los datos llamando a su función <code>add</code>, de la forma:<br/></p>
</li>
</ul>
<pre><code class="lang-javascript">notesStore.add(currentNote);
</code></pre>
<p>En el siguiente código de ejemplo se resumen los cuatro pasos que habría que seguir para cargar los datos del formulario &#39;noteEditor&#39; y guardarlos en el almacén &#39;notesStore&#39;.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Cargar el modelo de datos</span>
<span class="hljs-keyword">var</span> currentNote = noteEditor.getRecord();

<span class="hljs-comment">// Actualizar el modelo con los datos del formulario</span>
noteEditor.updateRecord(currentNote);

<span class="hljs-comment">// Realizar validaciones</span>
<span class="hljs-comment">// (ver siguiente apartado)</span>

<span class="hljs-comment">// Guardar los datos</span>
notesStore.add(currentNote);
</code></pre>
<p>Más comúnmente nuestro almacén estará asociado con algún elemento que nos permita visualizar los datos (como un listado o un <em>Data View</em>, ver secciones correspondientes). Si por ejemplo fuera un listado deberíamos de obtener la instancia del almacén de datos llamando a su método <code>getStore()</code> y posteriormente añadir los datos que habíamos obtenido del formulario de la forma:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> notesStore = notesList.getStore();
notesStore.add( currentNote );
</code></pre>
<p>Opcionalmente podemos comprobar si los datos a añadir están repetidos. Para esto tenemos que utilizar el método <code>findRecord()</code> del <em>store</em> (ver sección <em>Data Store</em>).</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> notesStore = notesList.getStore();

<span class="hljs-keyword">if</span>( notesStore.findRecord(<span class="hljs-string">'id'</span>, currentNote.data.id) === <span class="hljs-literal">null</span>)
{
   notesStore.add( currentNote );
}
</code></pre>
<p>Para terminar con el ejemplo del listado, una vez añadidos los datos tendremos que sincronizar su <em>store</em>, ordenarlo (si fuese necesario) y por último actualizar o refrescar la vista del listado:</p>
<pre><code class="lang-javascript">notesStore.sync();
notesStore.sort([{ property: <span class="hljs-string">'date'</span>, direction: <span class="hljs-string">'DESC'</span>}]);

notesList.refresh();
</code></pre>
<!-- ********************************************************************* -->
<h3 id="comprobar-validaciones">Comprobar validaciones</h3>
<p>Para comprobar las validaciones de un formulario lo tenemos que hacer de forma manual llamando a la función <code>validate()</code> del modelo de datos asociado. Para esto tienen que estar definidas estas validaciones en el modelo. Continuando con el ejemplo del modelo de datos &quot;Note&quot;, vamos a añadir que los campos <code>id</code>, <code>title</code> y <code>text</code> sean requeridos:</p>
<pre><code class="lang-javascript">Ext.define(<span class="hljs-string">'User'</span>, {
    extend: <span class="hljs-string">'Ext.data.Model'</span>,
    fields: [
        { name: <span class="hljs-string">'id'</span>, type: <span class="hljs-string">'int'</span> },
        { name: <span class="hljs-string">'date'</span>, type: <span class="hljs-string">'date'</span>, dateFormat: <span class="hljs-string">'c'</span> },
        { name: <span class="hljs-string">'title'</span>, type: <span class="hljs-string">'string'</span> },
        { name: <span class="hljs-string">'text'</span>, type: <span class="hljs-string">'string'</span> }
    ],
    validations: [
        { type: <span class="hljs-string">'presence'</span>, field: <span class="hljs-string">'id'</span> },
        { type: <span class="hljs-string">'presence'</span>, field: <span class="hljs-string">'title'</span>,
          message: <span class="hljs-string">'Introduzca un título para esta nota'</span> },
        { type: <span class="hljs-string">'presence'</span>, field: <span class="hljs-string">'narrative'</span>,
          message: <span class="hljs-string">'Introduzca un texto para esta nota'</span> }
    ]
});
</code></pre>
<p>Los pasos a seguir para realizar la validación de un formulario son los siguientes:</p>
<ul>
<li><p>Obtener el modelo de datos asociado a un formulario (<code>getRecord()</code>) y rellenarlo con los datos introducidos por el usuario (<code>updateRecord()</code>).</p>
</li>
<li><p>Llamar a la función <code>validate()</code> del modelo de datos. Esta función comprueba que se cumplan todas las validaciones que estén definidas en dicho modelo, devolviendo un objeto del tipo <code>Errors</code>.</p>
</li>
<li><p>A continuación usaremos la función <code>isValid()</code> del objeto <code>Errors</code> para comprobar si ha habido algún error. Esta función devuelve un valor <em>booleano</em> indicando si existen errores o no.</p>
</li>
<li><p>En caso de que existan errores tendremos que mostrar un aviso con los errores y no realizar ninguna acción más.</p>
</li>
<li><p>Dado que pueden haber varios errores (guardados en el array <code>items</code> del objeto <code>Errors</code>), tenemos que iterar por los elementos de este array usando la función <code>Ext.each(array, funcion)</code>. Esta función recibe dos parámetros: el primero es el array sobre el que va a iterar y el segundo la función que se llamará en cada iteración. Esta función recibe a su vez dos parámetros: el item de la iteración actual y el índice de ese item en el array.</p>
</li>
<li><p>Para mostrar el aviso con los errores podemos usar un <code>MessageBox</code> (ver sección correspondiente).</p>
</li>
</ul>
<p>A continuación se incluye un ejemplo completo de la validación de un formulario:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Cargar el modelo de datos</span>
<span class="hljs-keyword">var</span> currentNote = noteEditor.getRecord();

<span class="hljs-comment">// Actualizar el modelo con los datos del formulario</span>
noteEditor.updateRecord(currentNote);

<span class="hljs-comment">// Realizar validaciones</span>
<span class="hljs-keyword">var</span> errors = currentNote.validate();

<span class="hljs-keyword">if</span>(!errors.isValid())
{
    <span class="hljs-keyword">var</span> message=<span class="hljs-string">""</span>;

    Ext.each( errors.items, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item, index)</span> </span>{
        message += item.getMessage() + <span class="hljs-string">"&lt;br/&gt;"</span>;
    });

    Ext.Msg.alert(<span class="hljs-string">"Errores"</span>, message, Ext.emptyFn);

    <span class="hljs-keyword">return</span>;   <span class="hljs-comment">// Terminamos si hay errores</span>
}

<span class="hljs-comment">// Almacenar datos</span>
notesStore.add(currentNote);
</code></pre>
<p>También podríamos haber creado un bucle para iterar entre los elementos del array de errores, o haber llamado a la función <code>errors.getByField(&#39;title&#39;)[0].getMessage()</code> para obtener directamente el mensaje de error de un campo en concreto.</p>
<!-- *********************************************************************** -->
<h2 id="ms-informacin">Más información</h2>
<p>Podemos consultar principalmente tres fuentes de información cuando tengamos alguna duda:</p>
<ul>
<li><p>Los <strong>tutoriales y la sección de FAQ</strong> en la página Web de Sencha Touch:
<br/>
<a href="http://www.sencha.com/" target="_blank">http://www.sencha.com/</a></p>
</li>
<li><p>La <strong>documentación API</strong> Online:</p>
<ul>
<li><p><a href="http://docs.sencha.com/touch/2.4/2.4.1-apidocs/" target="_blank">http://docs.sencha.com/touch/2.4/2.4.1-apidocs/</a></p>
</li>
<li><p><a href="http://www.sencha.com/learn/touch/" target="_blank">http://www.sencha.com/learn/touch/</a></p>
</li>
<li><p>También disponible de forma local accediendo en la dirección &quot;/docs&quot; del SDK descargado.</p>
</li>
</ul>
</li>
<li><p>Los <strong>foros</strong> en la página web de Sencha Touch.</p>
</li>
</ul>
<p>Además en la carpeta &quot;touch-sdk/examples&quot; podemos encontrar aplicaciones de ejemplo.</p>
<!-- ********************************************************************* -->
<!-- ********************************************************************* -->
<!-- ********************************************************************* -->
<!-- ********************************************************************* -->
<!-- ********************************************************************* -->
<h1 id="ejercicios---aspectos-avanzados-de-sencha-touch">Ejercicios - Aspectos avanzados de Sencha Touch</h1>
<p>En esta sesión vamos a continuar con los ejercicios anteriores del editor de notas. Añadiremos los elementos necesarios para poder crear, editar, guardar y borrar notas, así como visualizarlas en un listado.</p>
<!-- ********************************************************************* -->
<h2 id="ejercicio-1---modelo-y-almacn-de-datos-08-puntos">Ejercicio 1 - Modelo y Almacén de datos (0.8 puntos)</h2>
<p>En este ejercicio vamos a crear el modelo de datos a utilizar y el almacén donde se van a guardar.</p>
<p>Nuestro modelo de datos llamado &#39;<code>Nota</code>&#39; tendrá cuatro campos:</p>
<ul>
<li>&#39;<em>id</em>&#39; de tipo &#39;<em>int</em>&#39;</li>
<li>&#39;<em>date</em>&#39; de tipo &#39;<em>date</em>&#39; y formato &#39;<em>c</em>&#39;</li>
<li>&#39;<em>title</em>&#39; de tipo &#39;<em>string</em>&#39;</li>
<li>&#39;<em>text</em>&#39; de tipo &#39;<em>string</em>&#39;</li>
</ul>
<p>Además deberemos definir las siguientes validaciones: los campos &#39;id&#39;, &#39;title&#39; y &#39;text&#39; serán requeridos, y para los campos &#39;title&#39; y &#39;text&#39; modificaremos el mensaje de error por defecto por &quot;Introduzca un título/texto&quot;.</p>
<blockquote>
<p>Los modelos de datos se tienen que guardar por separado en la carpeta designada para ello (<code>app/model</code>), además en la aplicación se tendrá que indicar al inicio los modelos que tiene que cargar (revisar el apartado &quot;Uso de modelos de datos en una aplicación&quot;).</p>
</blockquote>
<p>A continuación crearemos un almacén de datos (<em>Data Store</em>), lo guardaremos en la variable &#39;<em>storeNotas</em>&#39; y le indicaremos que tiene que usar el modelo &#39;<code>Nota</code>&#39; (recuerda que para los modelos hay que indicar todo el espacio de nombres). Como proxy vamos a usar el <strong>almacenamiento en local</strong>, indicando como identificador &#39;<em>misNotas-app-localstore</em>&#39;. Además lo configuraremos para que se ordenen los datos de forma descendente (DESC) por fecha (campo &#39;<em>date</em>&#39;) y que se carguen los datos del repositorio al inicio (<code>autoLoad: true</code>).</p>
<p>De forma temporal y para poder ver los resultados vamos a insertar datos en el <em>store</em>, añadiendo las siguientes líneas al mismo:</p>
<pre><code class="lang-javascript">data: [
    { id: <span class="hljs-number">1</span>, date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), title: <span class="hljs-string">'Test 1'</span>, text: <span class="hljs-string">'texto de prueba'</span> },
    { id: <span class="hljs-number">2</span>, date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), title: <span class="hljs-string">'Test 2'</span>, text: <span class="hljs-string">'texto de prueba'</span> },
    { id: <span class="hljs-number">3</span>, date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), title: <span class="hljs-string">'Test 3'</span>, text: <span class="hljs-string">'texto de prueba'</span> },
    { id: <span class="hljs-number">4</span>, date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), title: <span class="hljs-string">'Test 4'</span>, text: <span class="hljs-string">'texto de prueba'</span> }
]
</code></pre>
<!-- ********************************************************************* -->
<h2 id="ejercicio-2---listado-06-puntos">Ejercicio 2 - Listado (0.6 puntos)</h2>
<p>En este ejercicio vamos a añadir el listado donde se visualizarán los datos. En primer luegar creamos el listado en la variable &quot;<code>panelLista</code>&quot; y le indicamos que utilice el <em>store</em> &#39;storeNotas&#39; que hemos definido previamente.</p>
<p>En su sección <code>itemTpl</code> indicamos que muestre el campo <code>{title}</code> dentro de una capa tipo DIV con el estilo CSS &quot;<em>list-item-title</em>&quot;, y que el campo <code>{text}</code> lo muestre a continuación en otra capa tipo DIV con el estilo CSS &quot;<em>list-item-text</em>&quot;.</p>
<p>Este listado (&#39;panelLista&#39;) lo tendremos que añadir a nuestro panel &#39;panelContenedorLista&#39; en su sección <code>items</code> para poder visualizarlo.</p>
<p>Ahora tenemos que añadir esos estilos al fichero <em>app.css</em>. Para ambas clases (&#39;<em>list-item-title</em>&#39; y &#39;<em>list-item-text</em>&#39;) definiremos los mismos estilos (ver código siguiente), salvo para el &quot;<em>list-item-text</em>&quot; que además tendrá el texto en color gris.</p>
<pre><code class="lang-css"><span class="hljs-class">.list-item-title</span> <span class="hljs-rules">{  <span class="hljs-comment">/* Igual para: list-item-text */</span>
    <span class="hljs-rule"><span class="hljs-attribute">float</span>:<span class="hljs-value">left</span></span>;
    <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"><span class="hljs-number">100%</span></span></span>;
    <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"><span class="hljs-number">80%</span></span></span>;
    <span class="hljs-rule"><span class="hljs-attribute">white-space</span>:<span class="hljs-value"> nowrap</span></span>;
    <span class="hljs-rule"><span class="hljs-attribute">overflow</span>:<span class="hljs-value"> hidden</span></span>;
    <span class="hljs-rule"><span class="hljs-attribute">text-overflow</span>:<span class="hljs-value"> ellipsis</span></span>;
    <span class="hljs-comment">/* Para list-item-text añadimos 'color: gray;' */</span>
<span class="hljs-rule">}</span></span>
</code></pre>
<!-- ********************************************************************* -->
<h2 id="ejercicio-3---crear-y-editar-notas-08-puntos">Ejercicio 3 - Crear y Editar notas (0.8 puntos)</h2>
<p>Vamos a modificar la función <code>handler</code> del botón &quot;Nueva nota&quot; para que al pulsarlo, <strong>antes de realizar la transición</strong>, cree una nueva nota y la asigne al formulario. Para esto vamos a añadir una llamada a la función <code>crearNuevaNota()</code> (la cual crearemos de forma separada).</p>
<p>En la función <code>crearNuevaNota()</code> en primer lugar nos guardaremos la fecha actual <code>var now = new Date();</code>, y a continuación obtendremos el identificador único del registro a crear <code>var noteID = now.getTime();</code> (<em>con esta función transformamos la fecha en milisegundos, con lo que obtenemos un número que no se repite que podemos usar como ID</em>). A continuación creamos un registro del modelo &#39;<em>MisNotas.model.Nota</em>&#39; y lo cargamos en nuestro formulario (<code>panelFormulario.setRecord( note );</code>).</p>
<p>Por último vamos a añadir la funcionalidad de editar las notas creadas. Para esto vamos hasta el &#39;panelLista&#39;, y definimos su función <code>onItemDisclosure</code>. Esta función recoge un parámetro (<em>record</em>) que tenemos que cargar en el &#39;panelFormulario&#39; (<code>panelFormulario.setRecord( record );</code>). A continuación realizaremos una transición de tipo &#39;<em>slide</em>&#39; hacia la izquierda y con una duración de 1 segundo, para mostrar el &#39;panelFormulario&#39;.</p>
<!-- ********************************************************************* -->
<h2 id="ejercicio-4---guardar-y-borrar-notas-08-puntos">Ejercicio 4 - Guardar y Borrar notas (0.8 puntos)</h2>
<p>En este último ejercicio vamos a añadir las acciones de guardar y borrar nota. En las funciones <code>handler</code> de los botones &quot;Guardar&quot; y &quot;Borrar&quot; añadiremos llamadas a las funciones <code>guardarNota()</code> y <code>borrarNota()</code> respectivamente. Las llamadas a estas funciones las deberemos de incluir antes de realizar la transición. A continuación definiremos las acciones a realizar en estas funciones (que estarán definidas de forma separada).</p>
<p>En la función <code>guardarNota()</code> realizaremos los siguientes pasos:</p>
<ul>
<li><p>En primer lugar tendremos que cargar los datos introducidos en el formulario (usaremos la función <code>getRecord()</code> sobre la variable que contiene el formulario), y a continuación actualizaremos la instancia del formulario (ver sección &quot;Guardar los datos de un formulario&quot;).</p>
</li>
<li><p>En segundo lugar comprobaremos si hay algún error de validación y mostraremos los errores (ver apartado &quot;Comprobar validaciones&quot; de la sección &quot;Formularios&quot;).</p>
</li>
<li><p>Una vez validado el registro obtenido procederemos a guardar los datos. Obtenemos el <em>store</em> usado por el listado (<code>panelLista.getStore()</code>) y añadimos el registro solo si este no está repetido (función <code>findRecord()</code>).</p>
</li>
<li><p>Por último actualizamos el <em>store</em> (<code>sync()</code>), lo reordenamos por fecha y refrescamos el listado (<code>refresh()</code>).</p>
</li>
</ul>
<p>La función <code>borrarNota()</code> es más sencilla:</p>
<ul>
<li><p>Obtenemos el registro actual del formulario (<code>getRecord()</code>) y el <em>store</em> usado por el listado (<code>getStore()</code>).</p>
</li>
<li><p>A continuación comprobaremos si existe el registro actual en el <em>store</em> (usando su &quot;id&quot;) y si es así lo eliminaremos (ver apartado &quot;Eliminar registros&quot; de la sección &quot;<em>Data Store</em>&quot;).</p>
</li>
<li><p>Por último actualizaremos los datos del <em>Store</em> (<code>sync()</code>) y refrescamos el listado (<code>refresh()</code>).</p>
</li>
</ul>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="./capitulo_sencha_touch_2.html" class="navigation navigation-prev " aria-label="Previous page: Sencha Touch 2. Componentes"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="./capitulo_phonegap.html" class="navigation navigation-next " aria-label="Next page: PhoneGap 1. Introducción"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="gitbook/app.js"></script>

    
    <script src="https://cdn.mathjax.org/mathjax/2.4-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":null,"family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
